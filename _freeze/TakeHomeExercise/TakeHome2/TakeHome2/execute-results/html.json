{
  "hash": "a534ead46b86a820136167bc401aea20",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Take-Home Exercise 2\"\nauthor: \"Joshua TING\"\ndate: \"30 September, 2024\"\ndate-modified: \"last-modified\"\nformat:\n  html:\n    code-fold: true\n    code-summary: \"Code Chunk\"\n    number-sections: true\nexecute:\n  eval: true #r will run through all codes\n  echo: true #r will display all code chunk\n  warning: false #for mark down\n  freeze: true #r will not render all existing  html files\n  message: false #avoid printing warning message\neditor: source\n---\n\n\n# Take-Home Exercise 2: Discovering impacts of COVID-19 on Thailand tourism economy at the province level using spatial and spatio-temporal statistics\n\n## **Setting the Scene**\n\nTourism is one of Thailand’s largest industries, accounting for some 20% of the gross domestic product (GDP). In 2019, Thailand earned 90 billion US\\$ from domestic and international tourism, but the COVID-19 pandemic caused revenues to crash to 24 billion US\\$ in 2020.\n\nFigure below shows the total revenue receipt from tourism sector from January 2019 until Feb 2023. The figure reveals that the revenue from tourism industry have been recovered gradually since September 2021.\n\n## Objectives\n\nTo discover:\n\n-   if the key indicators of tourism economy of Thailand are independent from space and space and time.\n\n-   If the tourism economy is indeed spatial and spatio-temporal dependent, then, you would like to detect where are the clusters and outliers, and the emerging hot spot/cold spot areas.\n\n## Importing Packages\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(tidyverse, sf, spatstat, ggplot2, ggmap, tmap, dplyr, lubridate, raster, gtsummary, tidyr, spdep, knitr)\n```\n:::\n\n\n| Packages | Function |\n|------------------------------------|------------------------------------|\n| [**sf**](https://r-spatial.github.io/sf/) | To import, manage, and hande geospatial data |\n| [**tidyverse**](https://www.tidyverse.org/) | For non-spatial data wrangling |\n| [**sfdep**](https://sfdep.josiahparry.com/) | To compute spatial weights, global and local spatial autocorrelation statistics |\n| [spatstat](https://spatstat.org/) | For analysing spatial points |\n| [ggplot2](https://ggplot2.tidyverse.org/) | For data divisualisation |\n| [ggmap](https://cran.r-project.org/web/packages/ggmap/readme/README.html) | Retrieve raster map tiles from online mapping services |\n| [tmap](https://cran.r-project.org/web/packages/tmap/vignettes/tmap-getstarted.html) | Creating thematic maps |\n| [lubridate](https://lubridate.tidyverse.org/) | For robust date-time usage |\n| [**leaflet**](https://rstudio.github.io/leaflet/) | For interactive maps |\n| [**knitr**](https://cran.r-project.org/web/packages/knitr/) | For dynamic report generation |\n|  |  |\n\n|     |     |\n|-----|-----|\n|     |     |\n|     |     |\n|     |     |\n|     |     |\n|     |     |\n|     |     |\n|     |     |\n\n## Importing Packages\n\n### Importing Geopatial Data\n\nIn this section, `st_read()` of sf package is used to import 'tha_adm_rtsd_itos_20210121_shp' dataset into R enironment. `st_transform()` is used to transform the coordinate reference system (CRS) as we are assigning the boundary data for Thailand and the CRS is EPSG 32647.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nthaiboundary <- st_read(dsn = \"data/geospatial/tha_adm_rtsd_itos_20210121_shp/\",\n                      layer = \"tha_admbnda_adm1_rtsd_20220121\") %>%\n  st_transform(crs = 32647)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nReading layer `tha_admbnda_adm1_rtsd_20220121' from data source \n  `/Users/joshuatingsiyuan14/Desktop/isaiahting/ISSS626_GAA/TakeHomeExercise/TakeHome2/data/geospatial/tha_adm_rtsd_itos_20210121_shp' \n  using driver `ESRI Shapefile'\nSimple feature collection with 77 features and 16 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 97.34336 ymin: 5.613038 xmax: 105.637 ymax: 20.46507\nGeodetic CRS:  WGS 84\n```\n\n\n:::\n:::\n\n\nIn ensuring the right assignment of the coordinate reference system to the data, `st_crs()` is used.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nst_crs(thaiboundary)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nCoordinate Reference System:\n  User input: EPSG:32647 \n  wkt:\nPROJCRS[\"WGS 84 / UTM zone 47N\",\n    BASEGEOGCRS[\"WGS 84\",\n        ENSEMBLE[\"World Geodetic System 1984 ensemble\",\n            MEMBER[\"World Geodetic System 1984 (Transit)\"],\n            MEMBER[\"World Geodetic System 1984 (G730)\"],\n            MEMBER[\"World Geodetic System 1984 (G873)\"],\n            MEMBER[\"World Geodetic System 1984 (G1150)\"],\n            MEMBER[\"World Geodetic System 1984 (G1674)\"],\n            MEMBER[\"World Geodetic System 1984 (G1762)\"],\n            MEMBER[\"World Geodetic System 1984 (G2139)\"],\n            ELLIPSOID[\"WGS 84\",6378137,298.257223563,\n                LENGTHUNIT[\"metre\",1]],\n            ENSEMBLEACCURACY[2.0]],\n        PRIMEM[\"Greenwich\",0,\n            ANGLEUNIT[\"degree\",0.0174532925199433]],\n        ID[\"EPSG\",4326]],\n    CONVERSION[\"UTM zone 47N\",\n        METHOD[\"Transverse Mercator\",\n            ID[\"EPSG\",9807]],\n        PARAMETER[\"Latitude of natural origin\",0,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8801]],\n        PARAMETER[\"Longitude of natural origin\",99,\n            ANGLEUNIT[\"degree\",0.0174532925199433],\n            ID[\"EPSG\",8802]],\n        PARAMETER[\"Scale factor at natural origin\",0.9996,\n            SCALEUNIT[\"unity\",1],\n            ID[\"EPSG\",8805]],\n        PARAMETER[\"False easting\",500000,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8806]],\n        PARAMETER[\"False northing\",0,\n            LENGTHUNIT[\"metre\",1],\n            ID[\"EPSG\",8807]]],\n    CS[Cartesian,2],\n        AXIS[\"(E)\",east,\n            ORDER[1],\n            LENGTHUNIT[\"metre\",1]],\n        AXIS[\"(N)\",north,\n            ORDER[2],\n            LENGTHUNIT[\"metre\",1]],\n    USAGE[\n        SCOPE[\"Engineering survey, topographic mapping.\"],\n        AREA[\"Between 96°E and 102°E, northern hemisphere between equator and 84°N, onshore and offshore. China. Indonesia. Laos. Malaysia - West Malaysia. Mongolia. Myanmar (Burma). Russian Federation. Thailand.\"],\n        BBOX[0,96,84,102]],\n    ID[\"EPSG\",32647]]\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nglimpse(thaiboundary)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 77\nColumns: 17\n$ Shape_Leng <dbl> 2.417227, 1.695100, 1.251111, 1.884945, 3.041716, 1.739908,…\n$ Shape_Area <dbl> 0.13133873, 0.07926199, 0.05323766, 0.12698345, 0.21393797,…\n$ ADM1_EN    <chr> \"Bangkok\", \"Samut Prakan\", \"Nonthaburi\", \"Pathum Thani\", \"P…\n$ ADM1_TH    <chr> \"กรุงเทพมหานคร\", \"สมุทรปราการ\", \"นนทบุรี\", \"ปทุมธานี\", \"พระนครศรีอ…\n$ ADM1_PCODE <chr> \"TH10\", \"TH11\", \"TH12\", \"TH13\", \"TH14\", \"TH15\", \"TH16\", \"TH…\n$ ADM1_REF   <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ ADM1ALT1EN <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ ADM1ALT2EN <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ ADM1ALT1TH <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ ADM1ALT2TH <chr> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ ADM0_EN    <chr> \"Thailand\", \"Thailand\", \"Thailand\", \"Thailand\", \"Thailand\",…\n$ ADM0_TH    <chr> \"ประเทศไทย\", \"ประเทศไทย\", \"ประเทศไทย\", \"ประเทศไทย\", \"ประเทศ…\n$ ADM0_PCODE <chr> \"TH\", \"TH\", \"TH\", \"TH\", \"TH\", \"TH\", \"TH\", \"TH\", \"TH\", \"TH\",…\n$ date       <date> 2019-02-18, 2019-02-18, 2019-02-18, 2019-02-18, 2019-02-18…\n$ validOn    <date> 2022-01-22, 2022-01-22, 2022-01-22, 2022-01-22, 2022-01-22…\n$ validTo    <date> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA…\n$ geometry   <MULTIPOLYGON [m]> MULTIPOLYGON (((674339.8 15..., MULTIPOLYGON (…\n```\n\n\n:::\n:::\n\n\nAfter importing the dataset, we will plot the Thailand map using tmap.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_mode(\"plot\")\ntm_shape(thaiboundary) +\n  tm_fill(col = \"white\") +\n  tm_borders(col = \"black\", lwd = 0.3, alpha = 0.6) +\n  tm_layout(\n    main.title = \"Thailand Administrative Boundary\",\n    main.title.size = 0.8,\n    main.title.color = \"blue\",\n    main.title.position = \"center\",\n    legend.show = TRUE,\n    frame = FALSE\n  )\n```\n\n::: {.cell-output-display}\n![](TakeHome2_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n:::\n\n\n### Importing Aspatial Data\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrevenue <- read_csv(\"data/aspatial/thailand_domestic_tourism_2019_2023_ver2.csv\")\n```\n:::\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n:::\n\n\nThe data is then transposed. The \"date\" column is also converted to POSIXct for ease of manipulation at the later stage.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrevenue_transposed <- revenue %>%\n  mutate(date = as.POSIXct(date)) %>%\n  dplyr::select(-province_thai, -region_thai) %>%\n  pivot_wider(\n    names_from = variable,  # Use unique values in 'events' as column names\n    values_from = value,  # Fill new columns with values from 'value'\n    values_fill = list(value = 0)  # Fill NA with 0\n  )\n```\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"date\"          \"province_thai\" \"province_eng\"  \"region_thai\"  \n[5] \"region_eng\"    \"variable\"      \"value\"        \n```\n\n\n:::\n:::\n\n\n::: callout-tip\n## COVID-19 Pandemic in Thailand\n\nIn rooting the understanding of the COVID-19 situation in Thailand, it is important to read the [Wiki](https://en.wikipedia.org/wiki/COVID-19_pandemic_in_Thailand) page specifically under the section of Government Response.\n:::\n\nThe time period of pre-COVID19 was set from 1st January 2019 to 2nd April 2020 as quoted from Wiki \"*On 3 April, the Civil Aviation Authority of Thailand ordered that there would be a ban on all passengers flights landing in Thailand from the morning of 4 April to the evening of the 6 April..\"* under the section of Government Response - International Travel Restrictions. Following the closure of Thailand borders on 4th April 2020, the first series of border opening was 1st July 2021 as evidenced by \"*On 15 July 2021, it became possible for vaccinated holidaymakers from overseas to visit three islands in the Surat Thani province; Koh Samui, Koh Tao and Koh Phangan. The decision follows the reopening of Phuket, Thailand's largest island, on Thursday, July 1*\". Thus, the timeframe of COVID19 was set from 4th April 2020 - 30th June 2021. The Government of Thailand only lifted the restrictions such as PCR testing for fully-vaccinated travellers on 1st May 2022 as seen \"*Starting 1 May 2022, fully-vaccinated travellers will NOT require RT-PCR on arrival but still need Thailand Pass. ATK is voluntary only.*\" Thus the 2nd part of COVID19 pandemic in Thailand is 1st July 2021 to 30th April 2022. 1st May 2022 marks the reopening of the country borders hence, for this post COVID19 data is set from 1st May 2022 to 31st December 2023.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrevenue_transposed <- revenue_transposed %>%\n  mutate(\n    Period = case_when(\n      date >= as.Date(\"2019-01-01\") & date <= as.Date(\"2020-04-03\") ~ \"Pre-COVID\",\n      date >= as.Date(\"2020-04-04\") & date <= as.Date(\"2021-06-30\") ~ \"COVID_P1\",\n      date >= as.Date(\"2021-07-01\") & date <= as.Date(\"2022-04-30\") ~ \"COVID_P2\",\n      date >= as.Date(\"2022-05-01\") & date <= as.Date(\"2023-12-31\") ~ \"Post-COVID\",\n      TRUE ~ NA_character_  # For any dates outside these ranges\n    )\n  )\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nwrite_rds(revenue_transposed, \"data/rds/revenue_transposed.rds\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nrevenue_transposed = read_rds(\"data/rds/revenue_transposed.rds\")\n```\n:::\n\n\n### Combining Spatial Data Frame & Data Frame\n\n#### Checking Differences in both SF & DF\n\nPrior combining the SF & DF, we would want to compare the unique values (namely the provinces) in the columns `\"ADM1_EN\"` from the `thaiboundary` spatial data frame and `\"province_eng\"` from the `revenue_transposed` data frame. The `unique()` function helps to identify any differences between the two columns.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Get unique values from both columns\nunique_thaiboundary <- unique(thaiboundary$ADM1_EN)\nunique_revenue <- unique(revenue_transposed$province_eng)\n\n# Find differences\ndiff_thaiboundary <- setdiff(unique_thaiboundary, unique_revenue)  # In thaiboundary but not in revenue\ndiff_revenue <- setdiff(unique_revenue, unique_thaiboundary)      # In revenue but not in thaiboundary\n\n# Create a data frame to show differences\ndifference_table <- data.frame(\n  thaiboundary_only = diff_thaiboundary,\n  revenue_only = diff_revenue\n)\n\n# Print the differences\nprint(difference_table)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  thaiboundary_only    revenue_only\n1          Lop Buri         Lopburi\n2          Chai Nat         Chainat\n3         Chon Buri        Chonburi\n4      Prachin Buri     Prachinburi\n5          Buri Ram       Phang Nga\n6         Si Sa Ket         Buriram\n7  Nong Bua Lam Phu         Sisaket\n8          Phangnga Nong Bua Lamphu\n```\n\n\n:::\n:::\n\n\nNoticeably, we are able to witness the differences between both columns in the above output, this may result in missing values when combining both dataframes which is critical to our analysis. The differences are mainly due to the presence of white spaces.\n\nHenceforth, in the below code, we update the values in the `\"ADM1_EN\"` column of the `thaiboundary` spatial data frame by creating a mapping of the old values to the new values and then use the `dplyr` package to perform the replacement.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create a data frame for the mapping\nmapping <- data.frame(\n  old_value = c(\"Lop Buri\", \"Chai Nat\", \"Chon Buri\", \"Prachin Buri\", \"Buri Ram\", \n                \"Si Sa Ket\", \"Nong Bua Lam Phu\", \"Phangnga\"),\n  new_value = c(\"Lopburi\", \"Chainat\", \"Chonburi\", \"Prachinburi\", \"Buriram\", \n                \"Sisaket\", \"Nong Bua Lamphu\", \"Phang Nga\"),\n  stringsAsFactors = FALSE\n)\n\n# Create a named vector for recoding\nrecode_vector <- setNames(mapping$new_value, mapping$old_value)\n\n# Update the ADM1_EN column using recode_vector\nthaiboundary <- thaiboundary %>%\n  mutate(ADM1_EN = recode(ADM1_EN, !!!recode_vector))\n```\n:::\n\n\nThereafter, we perform a check again if there are still differences between columns `\"ADM1_EN\"` from the `thaiboundary` spatial data frame and `\"province_eng\"` from the `revenue` data frame. The results returned none which is reassuring to witness.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Get unique values from each column\nunique_adm1_en <- unique(thaiboundary$ADM1_EN)\nunique_province_eng <- unique(revenue$province_eng)\n\n# Compare unique values\ndifferences_adm1_en <- setdiff(unique_adm1_en, unique_province_eng)\ndifferences_province_eng <- setdiff(unique_province_eng, unique_adm1_en)\n\n# Create a data frame to show differences side by side\ncomparison_table_check <- tibble(\n  ADM1_EN_Not_In_Province = differences_adm1_en,\n  Province_Eng_Not_In_ADM1 = differences_province_eng\n)\n\n# Display the comparison table\nprint(comparison_table_check)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 0 × 2\n# ℹ 2 variables: ADM1_EN_Not_In_Province <chr>, Province_Eng_Not_In_ADM1 <chr>\n```\n\n\n:::\n:::\n\n\n#### Standardising Columns before Joining\n\n\n::: {.cell}\n\n```{.r .cell-code}\nthaiboundary <- thaiboundary %>%\n  rename(Province = ADM1_EN)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nrevenue_transposed <- revenue_transposed %>%\n  rename(Province = province_eng)\n```\n:::\n\n\n#### Combining SF & DF\n\nUnwanted columns also then removed for ease of wrangling.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncombined <- thaiboundary %>%\n  left_join(revenue_transposed, by = \"Province\")\n\ncombined <- combined %>%\n  dplyr::select(-ADM1_TH, -ADM1_PCODE, -ADM1_REF, -ADM1ALT1EN, \n                -ADM1ALT2EN, -ADM1ALT2TH, -ADM0_TH,\n                -ADM0_PCODE, -validTo)\n```\n:::\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nbasemap <- tm_shape(combined) +\n  tm_polygons() +\n  tm_text(\"Province\", size=0.5) +\n  tm_text(\"Period\")\n\nrev <- qtm(combined, \"revenue_all\")\ntmap_arrange(basemap, rev, asp=1, ncol=2)\n```\n\n::: {.cell-output-display}\n![](TakeHome2_files/figure-html/unnamed-chunk-24-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncolnames(combined)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"Shape_Leng\"         \"Shape_Area\"         \"Province\"          \n [4] \"ADM1ALT1TH\"         \"ADM0_EN\"            \"date.x\"            \n [7] \"validOn\"            \"date.y\"             \"region_eng\"        \n[10] \"ratio_tourist_stay\" \"no_tourist_stay\"    \"no_tourist_all\"    \n[13] \"no_tourist_thai\"    \"no_tourist_foreign\" \"revenue_all\"       \n[16] \"revenue_thai\"       \"revenue_foreign\"    \"Period\"            \n[19] \"geometry\"          \n```\n\n\n:::\n:::\n\n\nThe below code was run to simplify the gemetries through adjusting the tolerance.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncombined$geometry <- st_simplify(combined$geometry, dTolerance = 0.01)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Set the tmap mode to plot for static output\ntmap_mode('view')\n\n# Define the unique periods\nperiods <- c(\"Pre-COVID\", \"COVID_P1\", \"COVID_P2\", \"Post-COVID\")\n\n# Loop through each period and create a map\nfor (period in periods) {\n  # Subset data for the current period\n  current_data <- combined[combined$Period == period, ]\n\n  # Check if there's any data for the current period\n  if (nrow(current_data) == 0) {\n    next  # Skip to the next iteration if no data is found\n  }\n\n  # Create the basemap\n  basemap <- tm_shape(current_data) +\n    tm_polygons() +\n    tm_text(\"Province\", size = 0.5) +\n    tm_layout(main.title = paste(\"Period:\", period))\n\n  # Create the GDP map\n  revenue <- tm_shape(current_data) +\n    tm_polygons(\"revenue_all\") +\n    tm_layout(main.title = paste(\"Revenue in\", period))\n\n  # Combine the basemap and GDP map\n  combined_map <- tmap_arrange(basemap, revenue, asp = 1, ncol = 2)\n\nprint(combined_map)\n}\n```\n:::\n\n\n![](map_Pre-COVID.png)\n\n![](map_COVID_P1.png) ![](map_COVID_P2.png)\n\n![](map_Post-COVID.png)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwrite_rds(combinedmap, \"data/rds/combinedmap.rds\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncombinedmap = read_rds(\"data/rds/combinedmap.rds\")\n```\n:::\n\n\n## Exploratory Data Analysis\n\nThe code chunk below uses *st_area()* of **sf** package to derive the area of each province. We are creating a new column `Area` to store the area values.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncombined$Area <- combined %>%\n  st_area()\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# input: the dataframe and the variable name, chart style, title \nchoropleth_plot <- function(rev, varname, style, title) {\n  tm_shape(rev) +\n    tm_fill(varname, \n          n= 5,\n          style = style) +\n    tm_borders(alpha = 0.5) +\n    tm_layout(main.title = title,\n              main.title.size = 1,\n              main.title.position = \"center\",\n              legend.height = 0.45, \n              legend.width = 0.35,\n              frame = TRUE)+ \n    tm_compass(position = c('left','bottom'))\n}\ntmap_mode(\"plot\")\n```\n:::\n\n\n## Exploratory Spatial Data Analysis\n\n### Contiguity-based Spatial Weights\n\n#### **Contiguity-based (Queen) Spatial Weight Contiguity**\n\nIn the code chunk below, [*poly2nb()*](https://r-spatial.github.io/spdep/reference/poly2nb.html) of **spdep** package is used to compute contiguity weight matrices for the study area. This function builds a neighbours list based on regions with contiguous boundaries. By default, Queen contiguity is applied.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwm_q <- poly2nb(thaiboundary, queen=TRUE)\nsummary(wm_q)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNeighbour list object:\nNumber of regions: 77 \nNumber of nonzero links: 352 \nPercentage nonzero weights: 5.93692 \nAverage number of links: 4.571429 \n1 region with no links:\n67\n2 disjoint connected subgraphs\nLink number distribution:\n\n 0  1  2  3  4  5  6  7  8  9 \n 1  1  5 17 15 17 10  5  4  2 \n1 least connected region:\n14 with 1 link\n2 most connected regions:\n29 51 with 9 links\n```\n\n\n:::\n:::\n\n\nThe summary report above shows that there are 77 area units in Thailand. The most connected area unit has 9 links.\n\n#### **Contiguity-based (Rook) Spatial Weight Contiguity**\n\nIn the code chunk below, [*poly2nb()*](https://r-spatial.github.io/spdep/reference/poly2nb.html) of **spdep** package is used to compute contiguity weight matrices for the study area. We specify `queen = FALSE` to compute Rook contiguity.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwm_q <- poly2nb(thaiboundary, queen=FALSE)\nsummary(wm_q)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNeighbour list object:\nNumber of regions: 77 \nNumber of nonzero links: 352 \nPercentage nonzero weights: 5.93692 \nAverage number of links: 4.571429 \n1 region with no links:\n67\n2 disjoint connected subgraphs\nLink number distribution:\n\n 0  1  2  3  4  5  6  7  8  9 \n 1  1  5 17 15 17 10  5  4  2 \n1 least connected region:\n14 with 1 link\n2 most connected regions:\n29 51 with 9 links\n```\n\n\n:::\n:::\n\n\nThe summary report above shows that there are 77 area units in Thailand. The most connected area unit has 9 links.\n\nBoth of them possess the same number of link (4.57).\n\n### Distance-based Contiguity Weight Matrix\n\nWe will derive the distance-based weight matrices by using [*dnearneigh()*](https://r-spatial.github.io/spdep/reference/dnearneigh.html) of **spdep** package. The function identifies neighbours of region points by Euclidean distance with a distance band with lower and upper bounds controlled by the *bounds* argument or by Great Circle distance in kilometres if *longlat* argument is set to TRUE.\n\n#### **Fixed Distance Weight Matrix**\n\n**Determining the cut-off distance**\n\nTo ensure that each region has at least one neighbour, we need to find out the minimum distance within which all regions have at least oneneighbour. We can do this by following these steps:\n\n-   Getting the coordinates of polygon centroids. This is required as an input in the next step.\n\n    We need to associate each polygon with a point and its coordinates need to be in a separate data frame. We will use a mapping function that applies a given function to each element of a vector and returns a vector of the same length. Our input vector will be the geometry column of `thaiboundary`. Our function will be *st_centroid()*. We will be using *map_dbl()* variation of [map](https://www.rdocumentation.org/packages/purrr/versions/0.2.5/topics/map) from the **purrr** package. **purrr** is loaded when we load **tidyverse** package.\n\n-   To get our longitude values we map the *st_centroid()* function over the geometry column of thaiboundary and access the longitude value through double bracket notation \\[\\[\\]\\] and\n\n    1.  This allows us to get only the longitude, which is the first value in each centroid.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlongitude <- map_dbl(thaiboundary$geometry, ~st_centroid(.x)[[1]])\n```\n:::\n\n\nWe do the same for latitude with one key difference. We access the second value per each centroid with \\[\\[2\\]\\]\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlatitude <- map_dbl(thaiboundary$geometry, ~st_centroid(.x)[[2]])\n```\n:::\n\n\nNow that we have latitude and longitude, I used cbind to put longitude and latitude into the same object. We should check the first few observations to see if things are formatted correctly.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncoords <- cbind(longitude, latitude)\nhead(coords, 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     longitude latitude\n[1,]  675514.6  1523087\n[2,]  685033.7  1503755\n[3,]  650477.2  1539777\n[4,]  681656.0  1555581\n[5,]  664627.1  1586462\n```\n\n\n:::\n:::\n\n\n-   Return a matrix with the indices of points belonging to the set of the k nearest neighbours of each other by using [*knearneigh()*](https://r-spatial.github.io/spdep/reference/knearneigh.html) of **spdep.**\n\n-   Convert the knn object returned by *knearneigh()* into a neighbours list of class nb with a list of integer vectors containing neighbour region number ids by using [*knn2nb()*](https://r-spatial.github.io/spdep/reference/knn2nb.html).\n\n-   Return the length of neighbour relationship edges by using [*nbdists()*](https://r-spatial.github.io/spdep/reference/nbdists.html) of **spdep**. The function returns in the units of the coordinates if the coordinates are projected, in km otherwise.\n\n-   Remove the list structure of the returned object by using [unlist()](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/unlist).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nk1 <- knn2nb(knearneigh(coords, k = 1))\nk1dists <- unlist(nbdists(k1, coords))\nsummary(k1dists)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  21548   51966   64530   63281   76823  110987 \n```\n\n\n:::\n:::\n\n\nThe summary report shows that the largest first nearest neighbour distance is 110,987 metres, approximately 111, 000 metres. This will be used as the upper threshold as it gives certainty that all regions will have at least one neighbour.\n\n**Computing the fixed distance weight matrix**\n\nNow, we will compute the distance weight matrix by using [*dnearneigh()*](https://r-spatial.github.io/spdep/reference/dnearneigh.html) as shown below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwm_d111 <- dnearneigh(coords,0,111000)\nwm_d111\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNeighbour list object:\nNumber of regions: 77 \nNumber of nonzero links: 350 \nPercentage nonzero weights: 5.903188 \nAverage number of links: 4.545455 \n2 disjoint connected subgraphs\n```\n\n\n:::\n:::\n\n\nFrom the above code, we can see that the average number of links is 4.54.\n\nNext, we use *str()* to display the content of `wm_d111` weight matrix.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(wm_d111)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 77\n $ : int [1:12] 2 3 4 5 6 10 11 15 17 59 ...\n $ : int [1:10] 1 3 4 5 11 15 17 59 60 61\n $ : int [1:13] 1 2 4 5 6 8 10 17 56 58 ...\n $ : int [1:14] 1 2 3 5 6 8 10 15 16 17 ...\n $ : int [1:13] 1 2 3 4 6 7 8 9 10 17 ...\n $ : int [1:11] 1 3 4 5 7 8 9 10 17 58 ...\n $ : int [1:7] 5 6 8 9 10 17 48\n $ : int [1:10] 3 4 5 6 7 9 10 48 49 58\n $ : int [1:7] 5 6 7 8 48 49 58\n $ : int [1:9] 1 3 4 5 6 7 8 16 17\n $ : int [1:6] 1 2 12 13 15 16\n $ : int [1:3] 11 13 15\n $ : int [1:5] 11 12 14 15 18\n $ : int 13\n $ : int [1:9] 1 2 4 11 12 13 16 17 18\n $ : int [1:6] 4 10 11 15 17 18\n $ : int [1:10] 1 2 3 4 5 6 7 10 15 16\n $ : int [1:3] 13 15 16\n $ : int 20\n $ : int [1:2] 19 21\n $ : int [1:2] 20 22\n $ : int [1:2] 21 23\n $ : int [1:2] 22 26\n $ : int [1:3] 26 34 38\n $ : int [1:2] 29 55\n $ : int [1:4] 23 24 34 38\n $ : int [1:2] 32 36\n $ : int [1:4] 29 30 31 32\n $ : int [1:3] 25 28 33\n $ : int [1:3] 28 32 36\n $ : int 28\n $ : int [1:3] 27 28 30\n $ : int [1:3] 29 34 35\n $ : int [1:5] 24 26 33 35 38\n $ : int [1:4] 33 34 36 38\n $ : int [1:4] 27 30 35 37\n $ : int [1:2] 36 38\n $ : int [1:5] 24 26 34 35 37\n $ : int [1:3] 40 41 47\n $ : int [1:2] 39 41\n $ : int [1:3] 39 40 43\n $ : int [1:3] 43 52 53\n $ : int [1:4] 41 42 44 52\n $ : int [1:2] 43 45\n $ : int [1:2] 44 46\n $ : int 45\n $ : int 39\n $ : int [1:6] 7 8 9 49 50 54\n $ : int [1:6] 8 9 48 50 57 58\n $ : int [1:5] 48 49 51 52 54\n $ : int 50\n $ : int [1:4] 42 43 50 53\n $ : int [1:4] 42 52 54 55\n $ : int [1:4] 48 50 53 55\n $ : int [1:3] 25 53 54\n $ : int [1:5] 3 59 60 61 62\n $ : int [1:2] 49 58\n $ : int [1:9] 3 4 5 6 8 9 49 57 59\n $ : int [1:10] 1 2 3 4 5 6 56 58 60 61\n $ : int [1:9] 1 2 3 4 5 56 59 61 62\n $ : int [1:8] 1 2 3 4 56 59 60 62\n $ : int [1:4] 56 60 61 63\n $ : int 62\n $ : int [1:4] 65 68 73 74\n $ : int [1:5] 64 66 67 68 73\n $ : int [1:3] 65 67 68\n $ : int [1:2] 65 66\n $ : int [1:4] 64 65 66 69\n $ : int [1:2] 68 70\n $ : int 69\n $ : int [1:3] 72 74 75\n $ : int [1:3] 71 73 74\n $ : int [1:4] 64 65 72 74\n $ : int [1:4] 64 71 72 73\n $ : int [1:3] 71 76 77\n $ : int [1:2] 75 77\n $ : int [1:2] 75 76\n - attr(*, \"class\")= chr \"nb\"\n - attr(*, \"region.id\")= chr [1:77] \"1\" \"2\" \"3\" \"4\" ...\n - attr(*, \"call\")= language dnearneigh(x = coords, d1 = 0, d2 = 111000)\n - attr(*, \"dnn\")= num [1:2] 0 111000\n - attr(*, \"bounds\")= chr [1:2] \"GE\" \"LE\"\n - attr(*, \"nbtype\")= chr \"distance\"\n - attr(*, \"sym\")= logi TRUE\n```\n\n\n:::\n:::\n\n\nWe can observe that each region has different number of neighbours.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npar(mfrow = c(1,2))\nplot(thaiboundary$geometry, border = \"lightgrey\",main=\"1st nearest neighbours\" )\nplot(k1, coords, add = TRUE, col = \"red\", length = 0.88, )\n\nplot(thaiboundary$geometry, border = \"lightgrey\", main = \"Distance Link\")\nplot(wm_d111, coords, add = TRUE, pch = 19, cex = 0.6)\n```\n\n::: {.cell-output-display}\n![](TakeHome2_files/figure-html/unnamed-chunk-44-1.png){width=672}\n:::\n:::\n\n\nFrom the above output, we can make a few observations:\n\n-   It illustrates a characteristic of fixed distance weight matrix–more densely settled areas (usually the urban areas) tend to have more neighbours which is in instance it is in the middle where Bangkok resides and the less densely settled areas (usually the rural provinces) tend to have lesser neighbours\n\n-   The geographical areas of the regions in Thailand are largely varying. In the middle, bottom and top right, we see the neighbour links are dense especially in the middle and less dense in the rest of the regions where white spaces are\n\n-   Lastly, it is interesting to note that there is a dead space between the densely settled area of Bangkok region and the southern part of Thailand. This may indicate that tourism was not developed at all.\n\n#### **Adaptive Distance-based Weight Matrix**\n\nTo overcome the issue of fixed distance weight matrix where there is uneven distribution of neighbours, we can use directly control the numbers of neighbours using k-nearest neighbours, as shown in the code chunk below.\n\nAs a rule-of-thumb, we will set k = 8 i.e., all regions will have 8 neighbours.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nknn8 <- knn2nb(knearneigh(coords, k=8))\nknn8\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNeighbour list object:\nNumber of regions: 77 \nNumber of nonzero links: 616 \nPercentage nonzero weights: 10.38961 \nAverage number of links: 8 \nNon-symmetric neighbours list\n```\n\n\n:::\n:::\n\n\n**Plotting Adaptive Distance-based Neighbours**\n\n\n::: {.cell}\n\n```{.r .cell-code}\npar(mfrow = c(1,2))\nplot(thaiboundary$geometry, border = \"lightgrey\",main=\"8 nearest neighbours\" )\nplot(knn8, coords, add = TRUE, col = \"blue\", length = 0.88, )\n\nplot(thaiboundary$geometry, border = \"lightgrey\", main = \"Distance Link w KNN\")\nplot(knn8, coords, add = TRUE, col = \"red\", pch = 19, cex = 0.6)\n```\n\n::: {.cell-output-display}\n![](TakeHome2_files/figure-html/unnamed-chunk-46-1.png){width=672}\n:::\n:::\n\n\n### Spatial Weight Matrix to be Employed\n\nSelecting a spatial weight matrix is use is dependent on the geographical area of interest and the focus of the study^[8](https://isss624-amelia.netlify.app/exercises/take-home_ex1/take-home_ex1#fn8)^.\n\nIn this study, between contiguity-based and distance-based spatial weight matrices, we lean towards distance-based matrices. Within distance-based matrices, we will select the adaptive distance-based spatial weight matrix for our subsequent analysis.\n\nThe reasons are summarised here:\n\n-   Thailand has 77 provinces and it is relatively small . Hence, a contiguity-based matrix will have the issue where larger LGAs have more neighbours and smaller LGAs have lesser neighbours. This would likely skew our analysis. Therefore, distance-based methods are preferred.\n\n-   As mentioned earlier, the fixed distance-based method has the disadvantage that some regions would only have 1 neighbour, while on average regions have 23 neighbours. Statistical test for regions with only 1 neighbour may not be valid.\n\nBased on the above, we will select adaptive distance-based spatial weight matrix.\n\n### Row-Standardised Weights Matrix\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrswm_knn8 <- nb2listw(knn8,\n                   style = \"W\",\n                   zero.policy = TRUE)\nrswm_knn8\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nCharacteristics of weights list object:\nNeighbour list object:\nNumber of regions: 77 \nNumber of nonzero links: 616 \nPercentage nonzero weights: 10.38961 \nAverage number of links: 8 \nNon-symmetric neighbours list\n\nWeights style: W \nWeights constants summary:\n   n   nn S0       S1       S2\nW 77 5929 77 17.03125 319.9688\n```\n\n\n:::\n:::\n\n\nWe will be using the row-standardised weight matrix for the next part of the analysis.\n\n### 5.1.6 Computing Global Spatial Autocorrelation Statistics\n\nThis in sub-section, we will use two methods: Moran’s I and Geary’s C to test the hypothesis the following hypothesis:\n\n-   H0: Observed spatial patterns of values is equally likely as any other spatial pattern i.e. data is randomly disbursed, no spatial pattern\n\n-   H1: Data is more spatially clustered than expected by chance alone.\n\n#### 5.1.6.1 Moran’s I\n\nWe will perform Moran’s I statistical testing by using [*moran.test()*](https://r-spatial.github.io/spdep/reference/moran.test.html) of **spdep**. Moran’s I describe how features differ from the values in the study area as a whole. The Moran I statistic ranges from -1 to 1. If the Moran I is:\n\n-   positive (I\\>0): Clustered, observations tend to be similar\n\n-   negative (I\\<0): Disperse, observations tend to be dissimilar\n\n-   approximately zero: observations arranged randomly over space\n\nThe below code chunk will perform the Moran’s I test on both functional and non-functional water points.\n\n\n::: {.cell}\n\n:::\n",
    "supporting": [
      "TakeHome2_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}